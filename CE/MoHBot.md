import logging import subprocess import os import asyncio import pandas as pd from telegram import Update from telegram.ext import ( Application, CommandHandler, MessageHandler, filters, ConversationHandler, CallbackContext, ) # Enable logging logging.basicConfig( format='%(asctime)s - %(name)s - %(levelname)s - %(message)s', level=logging.INFO ) logger = logging.getLogger(\_\_name\_\_) # Define conversation states UPLOAD\_CSV, GET\_TOKEN, GET\_KEYS, GET\_HOST, GET\_TIME\_PERIOD, GET\_MOH\_OPTION, CONFIRM\_RUN = range(7) # --- Define the functions for the bot's conversation flow --- async def start(update: Update, context: CallbackContext) -> int: """Sends a message to the user and starts the conversation.""" await update.message.reply\_text( "Hello! I am a bot that uploads CSV data to ThingsBoard using your MoH script. " "Please, upload your CSV file to begin." ) return UPLOAD\_CSV async def upload\_csv(update: Update, context: CallbackContext) -> int: """Handles the uploaded file, verifies it's a CSV, and asks for the token.""" if update.message.document: file\_info = update.message.document if not file\_info.file\_name.endswith('.csv'): await update.message.reply\_text("The file must be a .csv file. Please try again.") return UPLOAD\_CSV file = await context.bot.get\_file(file\_info.file\_id) file\_path = f'./{file\_info.file\_name}' await file.download\_to\_drive(file\_path) context.user\_data\['csv\_path'\] = file\_path try: df = pd.read\_csv(file\_path, sep=';') columns = \[col for col in df.columns if col != 'Timestamp'\] if not columns: await update.message.reply\_text("The CSV file seems to be empty or has no columns besides 'Timestamp'. Please try again with a valid file.") os.remove(file\_path) return UPLOAD\_CSV context.user\_data\['available\_columns'\] = columns await update.message.reply\_text( f"CSV file '{file\_info.file\_name}' received.\\n\\n" f"Available columns:\\n- " + "\\n- ".join(columns) + "\\n\\nNow, please provide the \*\*ThingsBoard access token\*\* for the device." ) return GET\_TOKEN except Exception as e: await update.message.reply\_text(f"Error reading CSV file: {e}. Please try again.") os.remove(file\_path) return UPLOAD\_CSV else: await update.message.reply\_text("Please upload a CSV file.") return UPLOAD\_CSV async def get\_token(update: Update, context: CallbackContext) -> int: """Gets the ThingsBoard token from the user.""" token = update.message.text context.user\_data\['token'\] = token await update.message.reply\_text( "Token received. Now, from the list of available columns, " "please provide the \*\*telemetry keys\*\* you want to upload, separated by spaces." ) return GET\_KEYS async def get\_keys(update: Update, context: CallbackContext) -> int: """Gets the telemetry keys from the user.""" keys\_input = update.message.text keys = keys\_input.split() available\_columns = context.user\_data.get('available\_columns', \[\]) invalid\_keys = \[key for key in keys if key not in available\_columns\] if invalid\_keys: await update.message.reply\_text( f"The following keys are not in the CSV: {', '.join(invalid\_keys)}. " "Please provide valid keys from the list, separated by spaces." ) return GET\_KEYS context.user\_data\['keys'\] = keys await update.message.reply\_text( "Keys received. " "The default ThingsBoard host is \`http://localhost:8080\`. " "Would you like to use a different host? If so, please send me the URL. " "Otherwise, type 'default' to proceed with the default host." ) return GET\_HOST async def get\_host(update: Update, context: CallbackContext) -> int: """Gets the host from the user and prepares to get the time filter.""" user\_input = update.message.text if user\_input.lower() == 'default': host = 'http://localhost:8080' else: if not user\_input.startswith(('http://', 'https://')): await update.message.reply\_text("That doesn't look like a valid URL. Please send a valid host URL or type 'default'.") return GET\_HOST host = user\_input context.user\_data\['host'\] = host await update.message.reply\_text( f"ThingsBoard host set to: {host}. " "Now, please provide a time filter for the data. " "For example, type '7D' for the last 7 days, '1M' for the last month, or 'all' to upload all data." ) return GET\_TIME\_PERIOD async def get\_time\_period(update: Update, context: CallbackContext) -> int: """Gets the time filter from the user and prepares to get the MoH option.""" time\_filter = update.message.text context.user\_data\['time\_filter'\] = time\_filter await update.message.reply\_text( f"Time filter set to: {time\_filter}. " "Would you like to compute and upload the \*\*MoH metric\*\* for the selected telemetry? (yes/no)" ) return GET\_MOH\_OPTION async def get\_moh\_option(update: Update, context: CallbackContext) -> int: """Gets the MoH computation option from the user.""" moh\_option = update.message.text.lower() if moh\_option in \['yes', 'y'\]: context.user\_data\['compute\_moh'\] = True elif moh\_option in \['no', 'n'\]: context.user\_data\['compute\_moh'\] = False else: await update.message.reply\_text("Invalid option. Please respond with 'yes' or 'no'.") return GET\_MOH\_OPTION await update.message.reply\_text( f"MoH computation is set to: {context.user\_data\['compute\_moh'\]}. " "Ready to run the script. Please confirm by typing 'run'." ) return CONFIRM\_RUN async def run\_moh\_script(update: Update, context: CallbackContext) -> int: """Executes the MoH.py script with the gathered data and shows real-time progress.""" if update.message.text.lower() != 'run': await update.message.reply\_text("Please type 'run' to confirm.") return CONFIRM\_RUN csv\_path = context.user\_data.get('csv\_path') token = context.user\_data.get('token') keys = context.user\_data.get('keys') host = context.user\_data.get('host') time\_filter = context.user\_data.get('time\_filter') compute\_moh = context.user\_data.get('compute\_moh', False) if not all(\[csv\_path, token, keys, host, time\_filter\]): await update.message.reply\_text("Something went wrong. Please start again with /start.") return ConversationHandler.END progress\_message = await update.message.reply\_text( "Starting data upload... Please wait for progress updates." ) progress\_message\_id = progress\_message.message\_id try: command = \[ 'python', 'MoH.py', '--csv', csv\_path, '--keys', \*keys, '--token', token, '--host', host \] if compute\_moh: command.append('--moh') if time\_filter.lower() != 'all': command.extend(\['--time-filter', time\_filter\]) process = subprocess.Popen(command, stdout=subprocess.PIPE, stderr=subprocess.PIPE, text=True) while True: stdout\_line = process.stdout.readline() stderr\_line = process.stderr.readline() if not stdout\_line and not stderr\_line and process.poll() is not None: break if stdout\_line: if "Progress: Records sent" in stdout\_line: await context.bot.edit\_message\_text( chat\_id=update.effective\_chat.id, message\_id=progress\_message\_id, text=stdout\_line.strip() ) else: await update.message.reply\_text(stdout\_line.strip()) if stderr\_line: await update.message.reply\_text(f"⚠️ \*\*Error:\*\* {stderr\_line.strip()}") await asyncio.sleep(0.1) if process.returncode == 0: await context.bot.edit\_message\_text( chat\_id=update.effective\_chat.id, message\_id=progress\_message\_id, text=f"✅ Upload completed successfully!" ) else: await update.message.reply\_text(f"❌ Script finished with an error. Check the messages above for details.") except FileNotFoundError: await update.message.reply\_text("The \`MoH.py\` script was not found. Please ensure it is in the same directory as the bot.") finally: if os.path.exists(csv\_path): os.remove(csv\_path) return ConversationHandler.END async def cancel(update: Update, context: CallbackContext) -> int: """Cancels and ends the conversation.""" if 'csv\_path' in context.user\_data and os.path.exists(context.user\_data\['csv\_path'\]): os.remove(context.user\_data\['csv\_path'\]) await update.message.reply\_text('Operation cancelled. You can start again with /start.') return ConversationHandler.END def main(): """Start the bot.""" bot\_token = "7808597269:AAHJ1Xec87FZUZlNJoHJyubN\_Z27BIJHaio" application = Application.builder().token(bot\_token).build() conv\_handler = ConversationHandler( entry\_points=\[CommandHandler('start', start)\], states={ UPLOAD\_CSV: \[MessageHandler(filters.Document.FileExtension('csv'), upload\_csv)\], GET\_TOKEN: \[MessageHandler(filters.TEXT & ~filters.COMMAND, get\_token)\], GET\_KEYS: \[MessageHandler(filters.TEXT & ~filters.COMMAND, get\_keys)\], GET\_HOST: \[MessageHandler(filters.TEXT & ~filters.COMMAND, get\_host)\], GET\_TIME\_PERIOD: \[MessageHandler(filters.TEXT & ~filters.COMMAND, get\_time\_period)\], GET\_MOH\_OPTION: \[MessageHandler(filters.TEXT & ~filters.COMMAND, get\_moh\_option)\], CONFIRM\_RUN: \[MessageHandler(filters.TEXT & ~filters.COMMAND, run\_moh\_script)\], }, fallbacks=\[CommandHandler('cancel', cancel)\], ) application.add\_handler(conv\_handler) application.run\_polling() if \_\_name\_\_ == '\_\_main\_\_': main()